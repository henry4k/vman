Projektantrag:

Beschreibung:
    Bibliothek zum Management von Voxeldaten in einem unbegrenztem Raum:
    - Laden und Speichern zum Dateisystem.
    - Verwaltung und speicher-optimierte Lagerung der Daten im RAM.

Brainstorming:
    - KÃ¼mmert sich um das Laden und Speichern von Voxeln (=> Chunks).
    - Voxel haben mehrere Datenlayer, welche im Ausgangszustand keinen Speicher einnehmen, sondern von einem Default-Wert repräsentiert werden.
    - Von aussen hat man nur Zugriff auf Voxel-Ebene, die Chunks und Threads sind nur intern verfügbar.
    - C-Interface um die Bibliothek leichter in anderen Sprachen einbinden zu können.
    - Die Anwendung kann mit primitiven Objekten der Bibliothek sagen welche Voxel für sie gerade interessant sind, bzw welche bald interessant werden könnten.
    - Frisch geladene Chunks, sowie Chunks welcher länger nicht mehr geändert wurden, werden komprimiert im Speicher gehalten.
        - D.h. beim Laden könnten die komprimierten Voxel 1:1 im RAM landen.
    - Das Laden/Entladen passiert in Threads.
    - Die Applikation kann Events bzw Callbacks in der Bibliothek registrieren um Über Block-Änderungen u.Ä. informiert zu werden.
    - Die Applikation kann auch zusätzliche Daten für z.B. Tile-Entities verwalten lassen.
        - Diese werden dann z.B. im entsprechenden Chunk gespeichert.

Layer:
    Haben einen Namen und einen Versionsstring.
    Innerhalb der Anwendung werden sie Über einen Index angesprochen.





Chunks laden, wenn:
- Ein Access-Objekt diese benötigt
- Ein Pre-Load diese benötigt

Chunks entladen, wenn:
- Wenn sie seit einer bestimmten Zeit nicht mehr verwendet wurden.

Zu ladene Chunks sollten nach Priorität sortiert werden.
Preload- und Access-Objekte haben eine Priorität und priorisieren auch ihre Chunks.
Z.B. dass die innenliegenden Chunks einer Selection eine höhere Priorität als die Aussenliegenden haben.

Ein Volume Objekt hat einen Thread-Pool für RW-Jobs. R- und W-Jobs sollen gleichmäßig abgearbeitet werden.
Mutex rwJobMutex;
Condition newRWJobCondition;
Thread[] rwJobThreadPool;
int activeRJobs;
int activeWJobs;
list<RJob> rJobs;
list<WJob> wJobs;

addWJob( job ):
    rwJobMutex.lock();
        wJobs.push_back(job);
        sortWJobs();
        newRWJobCondition.signalOne();
    rwJobMutex.unlock();

rwJobThread():
    while(true):
        newRWJobCondition.wait();
        if(activeRJobs > activeWJobs)
            myNewJob = wJobs.pop();
        else:
            myNewJob = rJobs.pop();
        myNewJob.run();


- Chunk RefCounter
- Zeitstempel seit Unreferenziert
- Zeit die der Chunk referenziert wurde.
- Zeitstempel die der Chunk existiert.
- Daraus dann die anteilsweise Verwendung errechnen. :)
und soooh
- unloadUnusedChunks()
-

Fragt sich, ob das mit der "anteilsweisen Verwendung" so gut ist.
Das würde primÃ¤r genutzt werden um Chunks, die statistisch oft verwendet werden,
länger im Speicher zu halten.
Wenn man nun aber die Chunks zu jemanden kopiert der die so garnicht verwendet ...?
Erstmal weglassen. Kann man nacher ja immernoch gut einbauen. :)




Array-Funktionen für das Access-Objekt:

readVoxel( x, y, z, layer );
readVoxels( selection, callback, context );

void VoxelArrayRead( selection, const layers, context );







Manager
    const staticManager
        Layer Definitionen
        Chunk Kantenlänge

    getVolume( int id )

    Job-System
        ...

    Scheduling-System
        scheduleTask( Volume*, Chunk*, TaskId, ... )

    log-fn <- Thread-Safe

Volume
    BaseDir
    map<ChunkId, Chunk>
    getChunks

Chunk
    releaseReference -> Locks Manager :I
    setModified -> Locks Manager :I
        Beides wegen scheduleTask()




Manager:
    Layer Definitionen
    Chunk Kantenlänge









Policy:
    Mutex eines Objektes wird in der aufrufenden Funktion (also von aussen) gelockt.
    Von innen wird nie gelockt.

Chunk:
    benutzt scheduleTask (scheduledTasks-Liste)

Volume:
    benutzt Chunks

Access:
    benutzt Chunks
    benutzt Volume







Es darf von jedem Task pro Chunk nur einen geben.
Save darf nicht nach Unload kommen, in dem Fall mÃ¼sste Save mit Unload ausgeführt werden.

Meh.. das System hinkt an jeder Ecke.


v1:
    Bei entsprechenden Ereignissen wird ein Task in einen Scheduler eingetragen.
    Dieser wartet und bearbeitet die Tasks an ihrem Fälligkeitsdatum.

    + Läuft nur wenn es etwas zu tun gibt
    - Ist recht komplex, insbesondere da die Tasks bestimmte restriktionen haben.
      (Save darf nicht nach Unload usw.)


v2:
    Ein Service-Thread schaut alle N Sekunden in jedem Chunk nach ob
    dieser gespeichert und/oder entladen werden muss.

    + Simpel und (deswegen) zuverlÃ¤ssig
    - Thread läuft ständig


v3:
    Mischung aus v1 und v2:
    Bei entsprechenden Ereignissen wird in einem Scheduler eingetragen, dass der Chunk geprüft werden muss.
    Am Fälligkeitsdatum schaut der Scheduler im Chunk nach ob dieser entladen und/oder gespeichert werden muss.

    +- Mal sehen. :)




Statische Voxel und dynamische Voxel:

Statische Voxel-Layer haben eine feste Größe, welche sich nicht ändert. (ausser man kovertiert sie)
Bei dynamischen Voxel-Layer können die Voxel ihre Größe zur Laufzeit anpassen.

Voxel Layer enthält Pointer, welche auf die jeweiligen Daten verweisen.
Offline werden diese als Index-Werte gespeichert, welche auf einen Bereich in einen Daten-Array verweisen.








bool Access::readVoxelLayerAt(x,y,z,layer,&voxel)
void* Access::readVoxelLayerAt(x,y,z,layer)

- r/w/rw-Funktionen existieren aktuell nur für einzelne Voxel
- Operationen:
    - Chunk-Koordinaten rausfinden
    - Diverse Sicherheitschecks
    - ggf. Modified-Flag in Chunks setzen.

- In den meisten Fällen möchte man jedoch auf mehrere Voxel gleichzeitig zugreifen.

Alle Voxel werden kopiert:
bool Access::readVoxelLayerSelection(selection,layer,&out)

Mit Bit-Maske, welche die zu kopierenden Voxel angibt:
bool Access::readVoxelLayerSelectionWithMask(selection,layer,&mask,&out) hmm ....

Mit Callback, welches für jeden zusammenhängenden Abschnitt an Voxeln aufgerufen wird:
void* Access::readVoxelLayerSelection(selection,layer,callback)

void callback( Selection selection, void* data )
oder
void callback( int length, void* data )










- Globale und Volume-Spezifische Einstellungen als Key-Value-Paare?
    - vmanSetInt(manager, "io-threads", 4)
    - vmanVolumeSetString(volume, "base-directory", "/tmp/foo232")
















Volume und Access als Interface.
vmanCreateVolume() kann je nach Parametern unterschiedliche Volumen-Objekte erzeugen.
Die Parameter lassen sich wie bei OpenGL setzen/auslesen?
Das Volumen-Objekt erzeugt seine Access-Objekte.

Beispiel:

Volume3d
Access3d

Volume2d
Access2d


C-Funktionen geben mÃ¶glichst immer einen Fehlercode zurÃ¼ck. (0 == Alles okay)
Hm ... oder so? .. Weil ich mein, was soll man mit einem Fehlercode anfangen?
Also zu Wissen, *dass* der Aufruf fehlgeschlagen ist, macht auf jeden Fall Sinn.
Nur ob das Programm dann auch auf einen spezifischen Fehler reagieren wÃ¼rde ist fraglich.
Die korrekten Fehlernachrichten werden ohnehin Ã¼ber die Log-Funktion ausgegeben.



Allgemeines Panic-Callback-System, welches einen Mutex und eine verlinkte Liste benutzt.


Kompression:
    Jeder Layer hat eine eigene Kompressionsmethode,
    weil sich je nach gespeicherten Daten Kompressions-Methoden unterschiedlich gut eignen.

    Ideen für Kompressionsmethoden:
        - gzip o.Ä.:
            Generisch, könnte also allgemein neben differenzierten Methoden angewendet werden.

        - Differenz-Werte:
            Wie bei PNG werden Differenzwerte aus den Daten gebildet.
            Eignet sich bei Werten welche sich eher ändern über die Distanz ändern oder größere gleiche Flächen haben.
            Z.B. Luftdruck (langsame änderung), Material-IDs (größere flächen)

        - Daten beim speichern reduzieren/optimieren:
            Wenn aus Performance-Gründen auf 32bit Float-Werten gearbeitet wird, könnte man die Daten aber eventuell auch in einem kleineren Format abspeichern.
            Z.B. statt 32 bit float eben nur 16 oder 8 bit.
            Das ist bereits mit dem Conversion-Callback möglich.

        - ...


Memory-Soft-Cap:
    CheckChunk() entlÃ¤d keine Chunks solange eine bestimmte Speichernutzung der Chunks nicht Ã¼berschritten wurde.
    Immer wenn Speicher fÃ¼r einen Layer allokalisiert werden muss, wird getestet ob man sich noch unter dem Limit befindet.
    Falls nicht, werden solange unbenutzte Chunks gelÃ¶scht bis genÃ¼gend Speicher frei ist.
    Wenn es keine unbenutzen Chunks mehr gibt, wird normal weitergemacht. (Ist wie gesagt nur ein Soft-Cap!)
    Die unbenutzten Chunks werden Volume-Ãœbergreifend im Manager in einer verlinkten Liste gehalten.
    Neue unbenutzte Chunks werden ans Ende gelegt und sobald ein Chunk wieder genutzt wird, wird er aus der Liste gelÃ¶scht.

    Das ganze hat den Zweck die Zugriffszeiten zu verkleinern. (Solange bis der Speicher eben knapp wird.)



Manager bekommt mit wenn Volumes erzeugt/gelÃ¶scht werden.
Dieser hat einen Ref-Count auf alle Volumes, welche IO nutzen.
Die IO-Threads werden gestartet sobald der Ref-Count Ã¼ber 0 geht und gestoppt sobald er wieder bei 0 ist.



Es macht keinen Sinn mehrere Manager-Instanzen zu haben. Das verkompliziert die Sache nur.
Eigentlich braucht man insgesammt nur einen "Manager".
Dieser wÃ¼rde zu Anfangs mit vmanInit() erzeugt und mit vmanDeinit() am Ende gelÃ¶scht werden.




Volume speichert Referenzen o.Ã„. auf den jeweils letzten ScheduledChunk und I/O-Job.


Volume::saveAllModifiedChunks( int priorityOffset )
    Jetzt neu mit PrioritÃ¤tsoffset.

Manager::flushXYZ( Volume* volume )
    Setzt die PrioritÃ¤t der betroffenen EintrÃ¤ge hoch.
    Sortiert die Liste neu.
    Setzt die Referenzen im Volume.
    Wartet Ã¼ber mithilfe einer ConVar auf Abschluss.
    Die Worker-Threads triggern die ConVar sobald der letzte ScheduledChunk bzw I/O-Job bearbeitet wurde.

Manager::

Volume:
    ScheduledCheck m_LastScheduledCheck;
    ConVar         m_LastScheduledCheckDone;

    IOJob          m_LastIOJob;
    ConVar         m_LastIOJobDone;


API darf nichts über die zugrunde liegende Storage-Engine preisgeben.
D.h. die Options-Namen müssen als String übergeben werden.

Beispiele für Storage-Engines:
    - Chunk-Basierte Lösung
    - Remote (d.h. da läuft iwo ein vman-server mit welchem über tcp kommuniziert wird)
    - Occtree (Hm.. ja .. wer weiss ^^)
